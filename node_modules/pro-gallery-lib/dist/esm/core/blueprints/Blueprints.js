import { __assign } from "tslib";
/* eslint-disable prettier/prettier */
//dummy
import { Layouter } from 'pro-layouts';
import defaultStyles from '../../common/defaultStyles';
import { addPresetStyles } from '../presets/presets';
import dimensionsHelper from '../helpers/dimensionsHelper';
import { ItemsHelper } from '../helpers/itemsHelper';
import processLayouts from '../helpers/layoutHelper.js';
var Blueprints = /** @class */ (function () {
    function Blueprints() {
    }
    Blueprints.prototype.createBlueprint = function (_a) {
        // cacheBlocker
        // if (this.cache[params]) return this.cache[params];
        var params = _a.params, lastParams = _a.lastParams, existingBlueprint = _a.existingBlueprint, blueprintManagerId = _a.blueprintManagerId, isUsingCustomInfoElements = _a.isUsingCustomInfoElements;
        var changedParams = {};
        try {
            var newDimensionsParams = params.dimensions, newItemsParams = params.items, newStylesParams = params.styles;
            var oldDimensionsParams = lastParams.dimensions, oldItemsParams = lastParams.items, oldStylesParams = lastParams.styles;
            // getItems,styles and dimesions if not supplied in params;
            var _b = this.formatItemsIfNeeded(newItemsParams, oldItemsParams), formattedItems = _b.formattedItems, itemsChanged = _b.changed;
            var _c = this.formatStylesIfNeeded(newStylesParams, oldStylesParams, isUsingCustomInfoElements), formattedStyles = _c.formattedStyles, stylesChanged = _c.changed;
            var _d = this.formatContainerIfNeeded(newDimensionsParams, oldDimensionsParams, oldStylesParams, formattedStyles || existingBlueprint.styles, stylesChanged), formattedContainer = _d.formattedContainer, containerChanged = _d.changed;
            var changed = itemsChanged || stylesChanged || containerChanged;
            changedParams = { itemsChanged: itemsChanged, stylesChanged: stylesChanged, containerChanged: containerChanged };
            if (changed || !existingBlueprint) {
                if (!existingBlueprint) {
                    existingBlueprint = {};
                }
                var structure = this.createStructure({
                    formattedContainer: formattedContainer || existingBlueprint.container,
                    formattedItems: formattedItems || existingBlueprint.items,
                    formattedStyles: formattedStyles || existingBlueprint.styles,
                }, changed);
                // assign changed values w/o replacing the original object;
                if (formattedStyles) {
                    existingBlueprint.styles = formattedStyles;
                }
                if (formattedItems) {
                    existingBlueprint.items = formattedItems;
                }
                if (formattedContainer) {
                    existingBlueprint.container = formattedContainer;
                }
                existingBlueprint.structure = structure;
                // if its an infinite gallery - let the container loose
                var isInfinite = !existingBlueprint.styles.oneRow &&
                    existingBlueprint.styles.enableInfiniteScroll;
                if (isInfinite) {
                    existingBlueprint.container.height =
                        existingBlueprint.container.galleryHeight = structure.height;
                }
            }
        }
        catch (error) {
            console.error('Could not create blueprint, error:', error);
        }
        // return the existing or the modified existing object
        return { blueprint: existingBlueprint, changedParams: changedParams, blueprintManagerId: blueprintManagerId };
    };
    // ------------------ Raw data to Formated data (if needed) ---------------------------- //
    Blueprints.prototype.formatItemsIfNeeded = function (items, lastItems) {
        var reason = {
            items: '',
            itemsAdded: '',
        };
        var itemsWereAdded = function (newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                reason.itemsAdded = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                reason.itemsAdded = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                reason.itemsAdded = 'old items do not exist.';
                return false; // old items do not exist (it is not items addition)
            }
            if (oldItemsParams.length >= newItemsParams.length) {
                reason.itemsAdded = 'more old items than new items.';
                return false; // more old items than new items
            }
            var idsNotChanged = oldItemsParams.reduce(function (is, _item, idx) {
                // check that all the existing items exist in the new array
                return is && _item.id === newItemsParams[idx].itemId;
            }, true);
            if (!idsNotChanged) {
                reason.itemsAdded = 'items ids were changed. ';
            }
            return idsNotChanged;
        };
        var itemsHaveChanged = function (newItemsParams, oldItemsParams) {
            if (newItemsParams === oldItemsParams) {
                reason.items = 'items are the same object.';
                return false; // it is the exact same object
            }
            if (!newItemsParams) {
                reason.items = 'new items do not exist.';
                return false; // new items do not exist (use old items)
            }
            if (!oldItemsParams || (oldItemsParams && oldItemsParams.length === 0)) {
                reason.items = 'old items do not exist.';
                return true; // old items do not exist
            }
            if (oldItemsParams.length !== newItemsParams.length) {
                reason.items = 'more new items than old items (or vice versa).';
                return true; // more new items than old items (or vice versa)
            }
            return newItemsParams.some(function (newItem, idx) {
                // check that all the items are identical
                var existingItem = oldItemsParams[idx];
                try {
                    var itemsChanged = !newItem ||
                        !existingItem ||
                        newItem.itemId !== existingItem.itemId ||
                        newItem.mediaUrl !== existingItem.mediaUrl ||
                        newItem.measured !== existingItem.measured ||
                        (newItem.metaData &&
                            existingItem.metaData &&
                            (newItem.metaData.type !== existingItem.metaData.type ||
                                newItem.metaData.title !== existingItem.metaData.title ||
                                newItem.metaData.description !==
                                    existingItem.metaData.description)) ||
                        (newItem.metaData &&
                            newItem.metaData.type === 'text' &&
                            existingItem.metaData &&
                            existingItem.metaData.type === 'text' &&
                            (newItem.metaData.width !== existingItem.metaData.width ||
                                newItem.metaData.height !== existingItem.metaData.height ||
                                newItem.metaData.html !== existingItem.metaData.html ||
                                newItem.metaData.textStyle !==
                                    existingItem.metaData.textStyle ||
                                newItem.metaData.editorHtml !==
                                    existingItem.metaData.editorHtml));
                    if (itemsChanged) {
                        reason.items = "items #" + idx + " id was changed.";
                    }
                    return itemsChanged;
                }
                catch (e) {
                    reason.items = 'an error occured';
                    return true;
                }
            }, false);
        };
        var oldItemsParams = lastItems;
        var changed = false;
        var formattedItems;
        if (itemsWereAdded(items, oldItemsParams)) {
            formattedItems = oldItemsParams.concat(items.slice(oldItemsParams.length).map(function (item) {
                return ItemsHelper.convertDtoToLayoutItem(item);
            }));
            this.gettingMoreItems = false; // probably finished getting more items       //TODO - what is this and how we keep it alive if needed?
            changed = true;
        }
        else if (itemsHaveChanged(items, oldItemsParams)) {
            formattedItems = items.map(function (item) {
                return Object.assign(ItemsHelper.convertDtoToLayoutItem(item));
            });
            this.gettingMoreItems = false; // probably finished getting more items
            changed = true;
        }
        return { formattedItems: formattedItems, changed: changed };
    };
    Blueprints.prototype.formatStylesIfNeeded = function (styles, lastStyles, isUsingCustomInfoElements) {
        var reason = {
            styles: '',
        };
        var stylesHaveChanged = function (newStylesParams, oldStylesParams) {
            if (!newStylesParams) {
                reason.styles = 'no new styles.';
                return false; // no new styles - use old styles
            }
            if (!oldStylesParams) {
                reason.styles = 'no old styles.';
                return true; // no old styles
            }
            try {
                var oldStylesSorted_1 = {};
                Object.keys(oldStylesParams)
                    .sort() // sort by keys alphabetically
                    .forEach(function (key) { return (oldStylesSorted_1[key] = oldStylesParams[key]); });
                var newStylesSorted_1 = {};
                Object.keys(newStylesParams)
                    .sort() // sort by keys alphabetically
                    .forEach(function (key) { return (newStylesSorted_1[key] = newStylesParams[key]); });
                var wasChanged = JSON.stringify(newStylesSorted_1) !== JSON.stringify(oldStylesSorted_1);
                if (wasChanged) {
                    reason.styles = 'styles were changed.';
                }
                return wasChanged;
            }
            catch (e) {
                console.error('Could not compare styles', e);
                return false;
            }
        };
        var oldStylesParams = lastStyles;
        var changed = false;
        var formattedStyles;
        if (stylesHaveChanged(styles, oldStylesParams)) {
            styles = __assign(__assign({}, defaultStyles), styles);
            formattedStyles = processLayouts(addPresetStyles(styles), isUsingCustomInfoElements); // TODO make sure the processLayouts is up to date. delete addLayoutStyles from layoutsHelper when done with it...
            changed = true;
        }
        return { formattedStyles: formattedStyles, changed: changed };
    };
    Blueprints.prototype.formatContainerIfNeeded = function (dimensions, lastDimensions, lastStyles, formattedStyles, stylesChanged) {
        var reason = {
            dimensions: '',
        };
        var dimensionsHaveChanged = function (_a) {
            var newDimensionsParams = _a.newDimensionsParams, oldDimensionsParams = _a.oldDimensionsParams, oldStylesParams = _a.oldStylesParams;
            if (!oldStylesParams || !oldDimensionsParams) {
                reason.dimensions = 'no old dimensions or styles. ';
                return true; // no old dimensions or styles (style may change dimensions)
            }
            if (!newDimensionsParams) {
                reason.dimensions = 'no new dimensions.';
                return false; // no new continainer
            }
            var dimensionsHaveChanged = {
                height: !formattedStyles.oneRow && formattedStyles.enableInfiniteScroll // height doesnt matter if the new gallery is going to be vertical
                    ? false
                    : !!newDimensionsParams.height &&
                        newDimensionsParams.height !== oldDimensionsParams.height,
                width: !oldDimensionsParams ||
                    (!!newDimensionsParams.width &&
                        newDimensionsParams.width !== oldDimensionsParams.width),
                scrollBase: !!newDimensionsParams.scrollBase &&
                    newDimensionsParams.scrollBase !== oldDimensionsParams.scrollBase,
            };
            return Object.keys(dimensionsHaveChanged).reduce(function (is, key) {
                if (dimensionsHaveChanged[key]) {
                    reason.dimensions += "dimensions." + key + " has changed. ";
                }
                return is || dimensionsHaveChanged[key];
            }, false);
        };
        var oldDimensionsParams = lastDimensions;
        var changed = false;
        var oldStylesParams = lastStyles;
        var formattedContainer;
        if (stylesChanged || // If styles changed they could affect the container and a new container must be created (slideshow,thumbs,shadow,borders...etc)
            dimensionsHaveChanged({
                newDimensionsParams: dimensions,
                oldDimensionsParams: oldDimensionsParams,
                oldStylesParams: oldStylesParams,
            })) {
            dimensionsHelper.updateParams({
                styles: formattedStyles,
                container: dimensions,
            });
            changed = true;
            formattedContainer = Object.assign({}, dimensions, dimensionsHelper.getGalleryDimensions());
        }
        return { formattedContainer: formattedContainer, changed: changed };
    };
    Blueprints.prototype.createStructure = function (_a) {
        var formattedContainer = _a.formattedContainer, formattedStyles = _a.formattedStyles, formattedItems = _a.formattedItems;
        var layoutParams = {
            items: formattedItems,
            container: formattedContainer,
            styleParams: formattedStyles,
            options: {
                showAllItems: true,
                skipVisibilitiesCalc: true,
                useLayoutStore: false,
            },
        };
        // if (this.layouter && addingItems) {
        //   layoutParams.options.useExistingLayout = true;
        // } else {
        layoutParams.options.createLayoutOnInit = false; // TODO - what does this do?
        this.layouter = new Layouter(layoutParams); // TODO - no need for "this."
        // }
        return this.layouter.createLayout(layoutParams);
    };
    return Blueprints;
}());
var blueprints = new Blueprints();
export default blueprints;
/* eslint-enable prettier/prettier */
//# sourceMappingURL=Blueprints.js.map